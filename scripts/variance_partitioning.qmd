---
title: Partitioning variation of call structure at social scales in parrots
subtitle: Acoustic analysis
author: <a href="https://marce10.github.io/">Marcelo Araya-Salas</a> 
date: "`r Sys.Date()`"
toc: true
toc-depth: 4
toc-location: left
number-sections: true
highlight-style: pygments
format:
  html:
    df-print: kable
    code-fold: true
    code-tools: true
    css: qmd.css
    fig-height: 4
    fig-format: png
    fig-dpi: 200    
editor_options: 
  chunk_output_type: console
---

```{r set root directory}
#| eval: true
#| echo: false

# set working directory 
knitr::opts_knit$set(root.dir =  "..")

```

```{r add link to github repo}
#| eval: true
#| output: asis

# print link to github repo if any
if (file.exists("./.git/config")){
  config <- readLines("./.git/config")
  url <- grep("url",  config, value = TRUE)
  url <- gsub("\\turl = |.git$", "", url)
  cat("\nSource code and data found at [", url, "](", url, ")", sep = "")
  }

```

```{r setup style}
#| message: false
#| warning: false

# options to customize chunk outputs
knitr::opts_chunk$set(
  tidy.opts = list(width.cutoff = 65), 
  tidy = TRUE,
  message = FALSE
 )

options(DT.options = list(
    pageLength = 200,
    scrollX = TRUE,   # Horizontal scrolling
    scrollY = "800px" # Fixed-height vertical scrolling
  ))

```

```{r parameters and custom functions}
#| message: false
#| warning: false
#| 
# ggplot font size
bs <- 12

# custom functions
part_var <- function(model) {
var_components_pc1 <- as.data.frame(VarCorr(model))
total_variance <- sum(var_components_pc1$vcov)
var_components_pc1$proportion <- var_components_pc1$vcov / total_variance

return(var_components_pc1)    
}

# plot variance partitioning results
graph_part_var <- function(levels,
                           data,
                           by = NULL,
                           response,
                           full = TRUE) {
    if (!is.null(by)) {
        if (full) {
            by_levels <- c(unique(data[, by]), "full")
        } else {
            by_levels <- unique(data[, by])
        }
    } else
        by_levels <- "full"
    
    var_by_list <- lapply(by_levels, function(x) {
        if (x != "full") {
            formula <- paste0(response, " ~ (1 | ", paste(levels, collapse = " / "), ")")
        
            cat(paste0(x, ":", formula), "\n")
   
            dat <- droplevels(data[data[, by] == x, ])
        } else {
            dat <- droplevels(data)
            
            if (!is.null(by)){
            formula <- paste0(response, " ~ (1 | ", paste(levels, collapse = " / "), ") + (1 | ", by, ")")
            } else {
             formula <- paste0(response, " ~ (1 | ", paste(levels, collapse = " / "), ")")
            }
            
            cat("full:", formula, "\n")

        }
        
        model <- lmer(formula, data = dat)
        var_components <- part_var(model)
        var_components <- var_components[var_components$grp != "Residual", ]
        
        if (!is.null(by)) {
             var_components <- var_components[var_components$grp != by, ]
        }
        var_components$level <- factor(rev(levels), levels = rev(levels))
        
        # sample sizes
        var_components$n <- sapply(levels, function(y)
            length(unique(dat[, names(dat) == y])))
        
        var_components$prop <- as.character(round(var_components$proportion, 2))
        
        var_components$prop[var_components$prop == "0"] <- "< 0.01"
        
        var_components$prop <- paste(var_components$prop,
                                     " (n = ",
                                     var_components$n,
                                     ")",
                                     sep = "")
        
        var_components$by_levels <- x
        
        var_components$perc <- paste(
            round(var_components$proportion * 100, 0),
            "% (n = ",
            var_components$n,
            ")",
            sep = ""
        )
        
        return(var_components)
        
    })
    
    var_by_df <- do.call(rbind, var_by_list)
    
    var_by_df$by_levels <- factor(var_by_df$by_levels, levels = by_levels)
    
    gg_out <- ggplot(var_by_df, aes(x = level, y = proportion, fill = level)) +
        geom_bar(stat = "identity") +
        theme_classic(base_size = 20) +
        labs(x = "Level", y = "Explained variance (%)", fill = "Factor") +
        facet_wrap( ~ by_levels, ncol = 1) +
        theme(axis.text.x = element_text(
            angle = 45,
            vjust = 1,
            hjust = 1
        )) +
        geom_text(aes(label = perc), vjust = -0.5, size = 5) +
        scale_fill_viridis_d(
            option = "G",
            begin = 0.1,
            end = 0.9,
            guide = "none", direction = -1
                
        ) +
        scale_y_continuous(labels = label_percent(), limits = c(0, max(var_by_df$proportion) + 0.16))
    
    
    
    # Data for the nested ovals
oval_data <- data.frame(
    # label = c("A", "B", "C", "D"),
    x0 = c(0, 0, 0, 0, 0),                # Center x position for all ovals
    y0 = c(-1.7, -0.4, 0.7, 2.2, 3.3),                # Center y position for all ovals
    b = c(1.5, 3, 4.5, 6, 7.5),             # Semi-major axis (horizontal radius)
    a = c(2, 4, 6, 8, 10) + 1,                 # Semi-minor axis (vertical radius)
    text.pos = c(-4.7, -2, 1, 3.2, 6) + 3  # Radius for each circle
    
)

oval_data <- oval_data[seq_along(levels), ]
oval_data$label <- rev(levels)

oval_data$size <- oval_data$a * oval_data$b

# oval_data <- oval_data[oval_data$label %in% c("Site", "Bird"), ]  # Order by y0 for correct layering

# oval_data$label <- factor(oval_data$label, levels = rev(oval_data$label))
oval_data$label <- factor(oval_data$label, levels = oval_data$label[order(oval_data$size, decreasing = FALSE)])
oval_data$label.color <-  viridis::mako(nrow(oval_data), begin = 0.1, end = 0.9, direction = -1, alpha = 1)
oval_data$label.color <- factor(oval_data$label.color, levels = oval_data$label.color[order(oval_data$size, decreasing = TRUE)])

# oval_data <- oval_data[1:4,]

# Plot using ggplot2 and ggforce
gg_oval <- ggplot(oval_data, group = label) + 
    geom_ellipse(aes(x0 = x0, y0 = y0, a = a, b = b, angle = 0, fill = label.color), color = "white") +
    geom_text(aes(x = x0, y = text.pos, label = label), size = 7, color = c(rep("black", nrow(oval_data) - 1), "white")) + 
    # scale_fill_viridis_d(option = "G", begin = 0.1, end = 0.9, guide = "none", direction = 1) + # Add labels in the center
    scale_fill_identity() +  # Use the colors as specified in the data
    theme_void() +           # Remove background, axes, and grid
    theme(legend.position = "none") +
    coord_fixed()  #+          # Keep aspect ratio fixed for true ovals
    #ylim(c(-12, 6))
print(gg_oval)
 
return(gg_out)   
}

```


<!-- skyblue box -->

::: {.alert .alert-info}

# Purpose {.unnumbered .unlisted}

- Quantify contribution of different social levels of organization in the geographic variation of parrots calls.

:::



# Analysis flowchart {.unnumbered .unlisted}
```{mermaid}

flowchart LR
  A(Read data) --> B(Plot acoustic space) 
  B --> C(Regression models<br>to partition variance) 
  C --> D(Plot variance partition)

style A fill:#44015466
style B fill:#3E4A894D
style C fill:#26828E4D
style D fill:#6DCD594D

```

# Load packages {.unnumbered .unlisted}

```{r load packages}

# knitr is require for creating html/pdf/word reports
# formatR is used for soft-wrapping code

# install/ load packages
sketchy::load_packages(packages = c("knitr", "formatR", "warbleR", "ggplot2", "maRce10/PhenotypeSpace", "lme4", "scales", "Rtsne", "umap", "ggforce", "DT"))

```


# Thick-billed parrots

## MFCCs acoustic space by call type
```{r}
tbp_calls <- readRDS("./data/processed/extended_selection_table_tpb_calls.rds")
tbp_mfcc <- readRDS("./data/processed/mfcc_tpb_calls.rds")

datatable(tbp_calls)

# pca
pca <- prcomp(tbp_mfcc[, -c(1:2)], center = TRUE, scale. = TRUE)

tbp_calls$PC1.mfcc <- pca$x[, 1]
tbp_calls$PC2.mfcc <- pca$x[, 2]

ss_type <- space_similarity(type ~ PC1.mfcc + PC2.mfcc, data = as.data.frame(tbp_calls), method = "density.overlap")


# graph bidimensional space with gpplot coloring by type
ggplot(tbp_calls, aes(x = PC1.mfcc, y = PC2.mfcc, color = type)) +
  geom_point() +
  scale_colour_viridis_d(option = "G", begin = 0.2, end = 0.8, name = "Call type") +
  theme_classic(base_size = bs) +
  labs(title = paste0("Mean density overlap:", round(ss_type$mean.overlap, 2)), x = "PC1", y = "PC2")

```

## MFCCs acoustic space by site for each call type

PCA is computed separately for each call type
```{r}

tbp_calls$PC1.mfcc <- NA
tbp_calls$PC2.mfcc <- NA

for (i in unique(tbp_calls$type)){
pca <- prcomp(tbp_mfcc[tbp_calls$type == i, -c(1:2)], center = TRUE, scale. = TRUE)
tbp_calls$PC1.mfcc[tbp_calls$type == i] <- pca$x[, 1]
tbp_calls$PC2.mfcc[tbp_calls$type == i] <- pca$x[, 2]

# umap_l <- umap(tbp_mfcc[tbp_calls$type == i, -c(1:2)])
# tbp_calls$PC1.mfcc[tbp_calls$type == i] <- umap_l$layout[, 1]
# tbp_calls$PC2.mfcc[tbp_calls$type == i] <- umap_l$layout[, 2]
}

ss_type_barks <- space_similarity(Site ~ PC1.mfcc + PC2.mfcc, data = as.data.frame(tbp_calls[tbp_calls$type == "barks", ]), method = "density.overlap")
ss_type_laughs <- space_similarity(Site ~ PC1.mfcc + PC2.mfcc, data = as.data.frame(tbp_calls[tbp_calls$type == "laughs", ]), method = "density.overlap")

mean_ovlp <- mean(c(ss_type_barks$mean.overlap, ss_type_laughs$mean.overlap))
    
ggplot(tbp_calls, aes(x = PC1.mfcc, y = PC2.mfcc, color = Site)) +
  geom_point() +
  scale_colour_viridis_d(option = "G", begin = 0.2, end = 0.8, name = "Site") +
  theme_classic(base_size = bs) +
  facet_grid(~ type, scales = "free") +
  labs(title = paste0("Mean density overlap:", round(mean_ovlp, 2)), x = "PC1", y = "PC2") 

```

## Partition variance contribution

```{r}
#| eval: true
#| fig-height: 8

mod_barks <- lmer(PC1.mfcc ~ (1 | Site / UniqueBird), data = tbp_calls[tbp_calls$type == "barks", ])

graph_part_var(levels = c("Site", "UniqueBird"), data = as.data.frame(tbp_calls), by = "type", response = "PC1.mfcc", full = FALSE)


```


# Yellow-naped amazons

## MFCCs acoustic space by call type
```{r}
yna_mfcc <- readRDS("./data/processed/mfcc_yna_calls.rds")
yna_calls <- readRDS("./data/processed/extended_selection_table_yna_calls.rds")

datatable(yna_calls)

# pca
pca <- prcomp(yna_mfcc[, -c(1:2)], center = TRUE, scale. = TRUE)

yna_calls$PC1.mfcc <- pca$x[, 1]
yna_calls$PC2.mfcc <- pca$x[, 2]

ss_type <- space_similarity(type ~ PC1.mfcc + PC2.mfcc, data = as.data.frame(yna_calls), method = "density.overlap")


# graph bidimensional space with gpplot coloring by type
ggplot(yna_calls, aes(x = PC1.mfcc, y = PC2.mfcc, color = type)) +
  geom_point() +
  scale_colour_viridis_d(option = "G", begin = 0.2, end = 0.8, name = "Call type") +
  theme_classic(base_size = bs) +
  labs(title = paste0("Mean density overlap:", round(ss_type$mean.overlap, 2)), x = "PC1", y = "PC2")

```

## MFCCs acoustic space by site for each call type

PCA is computed separately for each call type
```{r}

yna_calls$PC1.mfcc <- NA
yna_calls$PC2.mfcc <- NA

for (i in unique(yna_calls$type)){
pca <- prcomp(yna_mfcc[yna_calls$type == i, -c(1:2)], center = TRUE, scale. = TRUE)
yna_calls$PC1.mfcc[yna_calls$type == i] <- pca$x[, 1]
yna_calls$PC2.mfcc[yna_calls$type == i] <- pca$x[, 2]

# umap_l <- umap(yna_mfcc[yna_calls$type == i, -c(1:2)])
# yna_calls$PC1.mfcc[yna_calls$type == i] <- umap_l$layout[, 1]
# yna_calls$PC2.mfcc[yna_calls$type == i] <- umap_l$layout[, 2]
}

yna_calls <- yna_calls[!is.na(yna_calls$Site), ]

ss_type_1994 <- space_similarity(Site ~ PC1.mfcc + PC2.mfcc, data = as.data.frame(yna_calls[yna_calls$type == "1994", ]), method = "density.overlap")
ss_type_2005 <- space_similarity(Site ~ PC1.mfcc + PC2.mfcc, data = as.data.frame(yna_calls[yna_calls$type == "2005", ]), method = "density.overlap")

mean_ovlp <- mean(c(ss_type_1994$mean.overlap, ss_type_2005$mean.overlap))
    
ggplot(yna_calls, aes(x = PC1.mfcc, y = PC2.mfcc, color = Site)) +
  geom_point() +
  scale_colour_viridis_d(option = "G", begin = 0.2, end = 0.8, name = "Site") +
  theme_classic(base_size = bs) +
  facet_grid(~ type, scales = "free") +
  labs(title = paste0("Mean density overlap:", round(mean_ovlp, 2)), x = "PC1", y = "PC2") 

```

## Partition variance contribution

```{r}
#| eval: true
#| fig-height: 8

graph_part_var(levels = c("Dialect", "Site", "UniqueBird"), data = as.data.frame(yna_calls), by = "type", response = "PC1.mfcc", full = TRUE)


```



# Monk parakeets

## MFCCs acoustic space by call type
```{r}
mpa_mfcc <- readRDS("./data/processed/mfcc_mpa_calls.rds")
mpa_calls <- readRDS("./data/processed/monk_parakeet_contactCalls_rangeComparison_extSelTable.RDS")

datatable(mpa_calls)

mpa_calls$country.region <- paste(mpa_calls$country, mpa_calls$region, sep = "-")

# pca
pca <- prcomp(mpa_mfcc[, -c(1:2)], center = TRUE, scale. = TRUE)

mpa_calls$PC1.mfcc <- pca$x[, 1]
mpa_calls$PC2.mfcc <- pca$x[, 2]

ss_type <- space_similarity(country ~ PC1.mfcc + PC2.mfcc, data = as.data.frame(mpa_calls), method = "density.overlap")


# graph bidimensional space with gpplot coloring by type
ggplot(mpa_calls, aes(x = PC1.mfcc, y = PC2.mfcc, color = country)) +
  geom_point() +
  scale_colour_viridis_d(option = "G", begin = 0.2, end = 0.8, name = "Country") +
  theme_classic(base_size = bs) +
  labs(title = paste0("Mean density overlap:", round(ss_type$mean.overlap, 2)), x = "PC1", y = "PC2") 

```

## MFCCs acoustic space by site for each call type

PCA is computed separately for each call type
```{r}

mpa_calls$PC1.mfcc <- NA
mpa_calls$PC2.mfcc <- NA

for (i in unique(mpa_calls$country)){
pca <- prcomp(mpa_mfcc[mpa_calls$country == i, -c(1:2)], center = TRUE, scale. = TRUE)
mpa_calls$PC1.mfcc[mpa_calls$country == i] <- pca$x[, 1]
mpa_calls$PC2.mfcc[mpa_calls$country == i] <- pca$x[, 2]

# umap_l <- umap(mpa_mfcc[mpa_calls$type == i, -c(1:2)])
# mpa_calls$PC1.mfcc[mpa_calls$type == i] <- umap_l$layout[, 1]
# mpa_calls$PC2.mfcc[mpa_calls$type == i] <- umap_l$layout[, 2]
}

ss_type_us <- space_similarity(country.region ~ PC1.mfcc + PC2.mfcc, data = as.data.frame(mpa_calls[mpa_calls$country == "United States", ]), method = "density.overlap")
ss_type_Uruguay <- space_similarity(country.region ~ PC1.mfcc + PC2.mfcc, data = as.data.frame(mpa_calls[mpa_calls$country == "Uruguay", ]), method = "density.overlap")


mean_ovlp <- mean(c(ss_type_us$mean.overlap, ss_type_Uruguay$mean.overlap))
    
ggplot(mpa_calls, aes(x = PC1.mfcc, y = PC2.mfcc, color = country.region)) +
  geom_point() +
  scale_colour_viridis_d(option = "G", begin = 0.2, end = 0.8, name = "country.region") +
  theme_classic(base_size = bs) +
  facet_grid(~ country, scales = "free") +
  labs(title = paste0("Mean density overlap: ", round(mean_ovlp, 2)), x = "PC1", y = "PC2") 

```

## Partition variance contribution

```{r}
#| eval: true
#| fig-height: 4

mpa_calls <- as.data.frame(mpa_calls)

graph_part_var(levels = c("country", "region", "dept_state", "site", "Bird_ID"), data = mpa_calls[!is.na(mpa_calls$Bird_ID), ], response = "PC1.mfcc", full = TRUE)

graph_part_var(levels = c("region", "dept_state", "site", "Bird_ID"), data = mpa_calls[!is.na(mpa_calls$Bird_ID), ], response = "PC1.mfcc", full = TRUE)

graph_part_var(levels = c("region", "site", "Bird_ID"), data = mpa_calls[!is.na(mpa_calls$Bird_ID), ], response = "PC1.mfcc", full = TRUE)

```


```{r}
#| eval: true
#| fig-height: 8

graph_part_var(levels = c("region", "site"), data = mpa_calls, response = "PC1.mfcc", full = TRUE, by = "range")

graph_part_var(levels = c("region", "dept_state", "site"), data = as.data.frame(mpa_calls), response = "PC1.mfcc", full = TRUE, by = "range")


```

<!-- light green box -->

::: {.alert .alert-success}

# Takeaways {.unnumbered .unlisted}

- Call type dependent variation in variance explained

::: 

&nbsp;

<!-- '---' adds a gray vertical line -->

---

&nbsp; 
 
 <!-- add packages used, system details and versions  -->
 
# Session information {.unnumbered .unlisted}

```{r session info}
#| echo: false

# if devtools is installed use devtools::session_info()
if (requireNamespace("devtools", quietly = TRUE)) {
  devtools::session_info()
} else {
  sessionInfo()
}

```
